import streamlit as st
# import torch
# import cv2
# import urllib
# import numpy as np
# from torchvision.transforms import Compose, Resize, ToTensor, Normalize
# import tempfile
from PIL import Image

@st.cache_data
def displayImage(img):
    st.image(img)

with st.container(key = 'upload', border = True):
    uploaded_file = st.file_uploader("Upload a Depth Map", type=["png"])

    if uploaded_file:
        image = Image.open(uploaded_file)
        st.session_state.depthMap = image
        st.image(st.session_state.depthMap.convert('RGB'))

    if st.button("Continue"):
        if uploaded_file:
            st.switch_page(st.session_state.roi_pg)
        else:
            st.error('Please select a depth map to proceed')


# with st.container(key='auto', border=True):

#     if 'img' in st.session_state:
#         # Load MiDaS model
#         midas = torch.hub.load("intel-isl/MiDaS", "DPT_Large")
#         midas.eval()

#         # Preprocess
#         transform = torch.hub.load("intel-isl/MiDaS", "transforms").dpt_transform

#         # # Read image from uploaded file
#         # st.session_state.img.seek(0)
#         # #file_bytes = np.asarray(bytearray(st.session_state.img.read()), dtype=np.uint8)
#         # file_bytes = np.asarray(bytearray(st.session_state.img), dtype=np.uint8)
#         # img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)

#         if st.session_state.img is not None:
#             img_rgb = cv2.cvtColor(np.array(st.session_state.img), cv2.COLOR_BGR2RGB)

            
#             input_tensor = transform(img_rgb)
#             if input_tensor.ndim == 3:
#                 input_tensor = input_tensor.unsqueeze(0)  # Add batch dimension if missing

#             # Inference
#             with torch.no_grad():
#                 prediction = midas(input_tensor)
#                 depth_map = prediction.squeeze().cpu().numpy()

#             # Normalize for visualization
#             depth_map = cv2.normalize(depth_map, None, 0, 255, cv2.NORM_MINMAX)
#             depth_map = depth_map.astype(np.uint8)

#             st.image(depth_map, caption="Autogenerated Depth Map", clamp=True)

#             if st.button("Continue with Autogenerated Depth Map"):
#                 # Save the depth map to a temporary file
#                 # with tempfile.NamedTemporaryFile(delete=False, suffix='.png') as temp_file:
#                 #    cv2.imwrite(temp_file.name, depth_map)
#                 st.session_state.depthMap = depth_map
#                 st.switch_page(st.session_state.roi_pg)
#         else:
#             st.write('Image not found')
#     else:
#         st.warning('Please upload an image to auto-generate a depth map.')

        